package malwaredetectionandroid;

 


import soot.Body;
import soot.MethodOrMethodContext;
import soot.PackManager;
import soot.PatchingChain;
import soot.Scene;
import soot.SootClass;
import soot.SootMethod;
import soot.Unit;

import soot.dexpler.instructions.MoveInstruction;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;

import org.xmlpull.v1.XmlPullParserException;

import soot.jimple.MonitorStmt;

import soot.jimple.NewExpr;
import soot.jimple.ReturnStmt;
import soot.jimple.AssignStmt;
import soot.jimple.GotoStmt;
import soot.jimple.ThrowStmt;
import soot.jimple.AnyNewExpr;
import soot.jimple.BinopExpr;
import soot.jimple.IfStmt;
import soot.jimple.ArrayRef;
import soot.jimple.InvokeStmt;
import soot.jimple.Jimple;
import soot.jimple.JimpleBody;
import soot.jimple.StaticFieldRef;
import soot.jimple.StmtSwitch;
import soot.jimple.SwitchStmt;
import soot.jimple.InvokeExpr;
import soot.jimple.NopStmt;


import soot.jimple.infoflow.android.SetupApplication;
import soot.jimple.toolkits.callgraph.CallGraph;
import soot.jimple.toolkits.callgraph.Edge;
import soot.options.Options;
import soot.util.Chain;



public class CallGraphExample {
    
	public static int[] calLabel(Body b){
		int hash[]=new int[14];
		for(int i=0;i<14;i++){
			hash[i]=0;
		}
		// Getting chain of instructions in a function
		PatchingChain<Unit> pUnit = b.getUnits();
		
		//Unt.println(" pUnit ---> "+ pUnit+"\n");
		Iterator<Unit> iterUnit = pUnit.iterator();
		
		while(iterUnit.hasNext())
		{
			Unit u = iterUnit.next();
									
			// classifying the type of instruction
			if (u instanceof NopStmt)
	        {   hash[0]=1;}
	        else if (u instanceof  MoveInstruction)
	        {	hash[1]=1;            
	          
	        } else if (u instanceof  ReturnStmt)
	        {	hash[2]=1;
	         	        	       
	        } else if ( u instanceof MonitorStmt)
	        { 	hash[3]=1;
	         				        	       
	        } else if (u instanceof NewExpr)
	        {  	hash[4]=1;
	        
	        } else if (u instanceof ThrowStmt)
	        {  	hash[5]=1;
	            					        	       
	        } else if (u instanceof GotoStmt)
	        {  	hash[6]=1;
	              	       
	        } else if (u instanceof IfStmt|| u instanceof SwitchStmt)
	        { 	hash[7]=1;
	        
	        } else if (u instanceof InvokeStmt)
	        { 	hash[8]=1;
	            
	        }else if (u instanceof StaticFieldRef)
	        {  	hash[9]=1;
	        
	        }else if (u instanceof AssignStmt)
	        {  	hash[10]=1;
	            
	        }else if (u instanceof BinopExpr)
	        {  	hash[11]=1;
	            
	        }else if (u instanceof ArrayRef)
	        {  	hash[12]=1;
	            
	        }else if (u instanceof AnyNewExpr)
	        {  	hash[13]=1;
	            
	        }
		}
		return hash;
		
	}
        
       

	public static int[] findhist(String filepath) throws IOException{
		
		
                 int[] Output = new int[900];// 2^15 array size
		
		
	
		
		System.out.println("Starting the Preprocessing of android application");
                String androSdkPath=System.getProperty("user.dir");
		SetupApplication app = new SetupApplication(androSdkPath+"\\android-platforms", filepath);
		
		try {
			app.calculateSourcesSinksEntrypoints(androSdkPath+"\\FlowDroid\\SourcesAndSinks.txt");
		} catch (Exception e) {
			// TODO Auto-generated catch block
			return Output;
		}
	    soot.G.reset();

	    // Options given at the time of running
	    Options.v().set_src_prec(Options.src_prec_apk);
	    Options.v().set_process_dir(Collections.singletonList(filepath));
	    Options.v().set_android_jars(androSdkPath+"\\android-platforms");
	    Options.v().set_whole_program(true);
	    Options.v().set_allow_phantom_refs(true);
	    Options.v().set_output_format(Options.output_format_jimple);
	    Options.v().setPhaseOption("cg.spark", "on");
	    Options.v().dump_cfg();
	    

	    Scene.v().loadNecessaryClasses();
	    SootMethod entryPoint = app.getEntryPointCreator().createDummyMain();
	    Options.v().set_main_class(entryPoint.getSignature());
	    Scene.v().setEntryPoints(Collections.singletonList(entryPoint));
	    
	    
	   
	    // Analysis starts
	    try
	    {
	    PackManager.v().runPacks();
	    }catch(Exception e)
	    {
	    	
	    	return Output;
	    }
	      
	    
	    CallGraph c=Scene.v().getCallGraph();
	    HashMap<String, int[]> Mymap = new HashMap<>();
	   
	    
	    // File to store the output
	//	PrintWriter Met=new PrintWriter(new File("MethodBody.txt"));// to store method source code(jimple)
	//	PrintWriter Unt=new PrintWriter(new File("UnitBody.txt")); // to store units
//		PrintWriter ou=new PrintWriter(new File("output.txt")); // to store call graph
	    
	//	ou.println("Call Graph size: "+Scene.v().getCallGraph().size());
		//ou.println(c);

		Iterator<Edge> egIter =  c.iterator();
		while(egIter.hasNext()){
			try{
			Edge eg = egIter.next();
			//Unt.print("\n Edge: "+ eg);
			//Unt.println("Taget: "+eg.getTgt()+"Source: "+ eg.getSrc());
			SootMethod source= eg.src();
			SootMethod dest = eg.tgt();
			//Unt.println(" "+ eg.src()+ " ----> "+eg.tgt());
			Body srcBody =  source.getActiveBody();
			Body destBody =  dest.getActiveBody();
			//Met.println("Source Method Name ----> "+source.getName());
			
			
			int hash2[] = calLabel(srcBody);
			int hash3[] = calLabel(destBody);
			
			
			
			//Met.print("Hash2: ");
			//for(int i=0;i<14;i++)
			//Met.print(" "+ hash2[i]);
			//Met.print("\n");

			//Met.println("Destination Method Name ----> "+dest.getName());
			//Met.print("Hash3: ");
			//for(int i=0;i<14;i++)
			//Met.print(" "+ hash3[i]);
			//Met.print("\n");
			
			if(Mymap.get(source.getName())== null){
				Mymap.put(source.getName(), hash2);			
			}
			
				int[] temp = Mymap.get(source.getName());
				for(int i=0;i<14;i++){
				temp[i]=temp[i]+hash3[i];	
				}
				Mymap.put(source.getName(), temp);
			
			
			if(Mymap.get(dest.getName())== null){
				Mymap.put(dest.getName(), hash2);			
			}
			
				int[] temp2 = Mymap.get(dest.getName());
				for(int i=0;i<14;i++){
				temp2[i]=temp2[i]+hash2[i];	
				}
				Mymap.put(dest.getName(), temp2);
			
			//Unt.println(Mymap);
			
		       //	 System.out.println(pair.getKey());
		        
		       
		       // it.remove(); // avoids a ConcurrentModificationException
		   }
			catch(Exception e){
				//System.out.println(e);
			}
			
		}// end of loop
		Iterator it = Mymap.entrySet().iterator();
		  int count =0; 
	    while (it.hasNext()) {
	        Map.Entry pair = (Map.Entry)it.next();
	        int[] temp = (int[]) pair.getValue();
	        
	        //Unt.print(pair.getKey()+": "  );
	        //Unt.print("Hash: ");
	      
	        int hval22=0;
	        for(int i=1;i<15;i++){
	        	//Unt.print(temp[i%14]%2);
	        	hval22=hval22 + (temp[i%14]%2)*(int)Math.pow(2, i-1);
	        	//System.out.println((temp[i%14]%2)*(int)Math.pow(2, i-1));
	        	
	        }
	        //System.out.println(hval22);
	        if((hval22>0)){
	        	count++;
	        }
	        Output[hval22]+=1;
	        //Unt.println("\n");
	    }
	    //System.out.println(count);
	   
	    
	    return Output;
	   
	}
	
	
}
